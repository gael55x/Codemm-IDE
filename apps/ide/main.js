/* eslint-disable no-console */
const { app, BrowserWindow, dialog, shell, ipcMain, safeStorage } = require("electron");
const { spawn, spawnSync } = require("child_process");
const crypto = require("crypto");
const fs = require("fs");
const http = require("http");
const net = require("net");
const os = require("os");
const path = require("path");
const { z } = require("zod");

const DEFAULT_FRONTEND_PORT = Number.parseInt(process.env.CODEMM_FRONTEND_PORT || "3000", 10);
const OLLAMA_DEFAULT_URL = "http://127.0.0.1:11434";

// Keep a global reference so the window isn't garbage-collected on macOS.
/** @type {import("electron").BrowserWindow | null} */
let mainWindow = null;
let ipcWired = false;
let currentWorkspace = null; // { workspaceDir, workspaceDataDir, backendDbPath, userDataDir }
let engine = null; // { proc, call, onEvent, shutdown }

function getPathKey(env) {
  if (!env || typeof env !== "object") return "PATH";
  const found = Object.keys(env).find((k) => k.toLowerCase() === "path");
  return found || "PATH";
}

function prependToPath(env, dir) {
  const key = getPathKey(env);
  const delim = path.delimiter || ":";
  const cur = typeof env[key] === "string" ? env[key] : "";
  env[key] = cur ? `${dir}${delim}${cur}` : dir;
}

function getNpmBin() {
  return process.platform === "win32" ? "npm.cmd" : "npm";
}

function tryRegisterIpcHandler(channel, handler) {
  try {
    ipcMain.handle(channel, handler);
  } catch (e) {
    // If the handler is already registered (dev reloads, multi-window), ignore.
    // eslint-disable-next-line no-console
    console.warn(`[ide] IPC handler already registered: ${channel}`);
  }
}

function tryRegisterIpcListener(channel, listener) {
  try {
    if (ipcMain.listenerCount(channel) > 0) return;
    ipcMain.on(channel, listener);
  } catch {
    // ignore
  }
}

// Register a small set of handlers early so UI actions don't depend on the workspace boot path.
tryRegisterIpcHandler("codemm:ollama:openInstall", async () => {
  await shell.openExternal("https://ollama.com/download");
  return { ok: true };
});
tryRegisterIpcListener("codemm:ollama:openInstall", () => {
  shell.openExternal("https://ollama.com/download").catch(() => {});
});

function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

function redactSecrets(text) {
  const raw = typeof text === "string" ? text : String(text ?? "");
  return raw
    // OpenAI-style keys
    .replace(/\bsk-[A-Za-z0-9]{10,}\b/g, "sk-[REDACTED]")
    // Generic bearer tokens
    .replace(/\bBearer\s+[A-Za-z0-9._-]{10,}\b/g, "Bearer [REDACTED]")
    // JSON-ish fields we might accidentally stringify
    .replace(/(\"apiKey\"\s*:\s*\")([^\"]+)(\")/gi, `$1[REDACTED]$3`)
    .replace(/(\"apiKeyEncB64\"\s*:\s*\")([^\"]+)(\")/gi, `$1[REDACTED]$3`);
}

function expandTilde(p) {
  if (p === "~") return os.homedir();
  if (p.startsWith("~/") || p.startsWith("~\\")) return path.join(os.homedir(), p.slice(2));
  return p;
}

function configureElectronStoragePaths() {
  const userDataOverride = typeof process.env.CODEMM_USER_DATA_DIR === "string" ? process.env.CODEMM_USER_DATA_DIR.trim() : "";
  const cacheOverride = typeof process.env.CODEMM_CACHE_DIR === "string" ? process.env.CODEMM_CACHE_DIR.trim() : "";
  const logsOverride = typeof process.env.CODEMM_LOGS_DIR === "string" ? process.env.CODEMM_LOGS_DIR.trim() : "";

  let userDataDir = userDataOverride ? expandTilde(userDataOverride) : app.getPath("userData");
  if (!path.isAbsolute(userDataDir)) userDataDir = path.resolve(userDataDir);

  // Ensure dirs exist before Chromium tries to create caches (prevents noisy "Failed to write ... index file" errors).
  fs.mkdirSync(userDataDir, { recursive: true });
  if (userDataOverride) app.setPath("userData", userDataDir);

  let cacheDir = cacheOverride ? expandTilde(cacheOverride) : path.join(userDataDir, "Cache");
  if (!path.isAbsolute(cacheDir)) cacheDir = path.resolve(cacheDir);
  fs.mkdirSync(cacheDir, { recursive: true });
  app.setPath("cache", cacheDir);

  let logsDir = logsOverride ? expandTilde(logsOverride) : path.join(userDataDir, "Logs");
  if (!path.isAbsolute(logsDir)) logsDir = path.resolve(logsDir);
  fs.mkdirSync(logsDir, { recursive: true });
  app.setPath("logs", logsDir);

  return { userDataDir, cacheDir, logsDir };
}

function readJsonFile(filePath, fallback) {
  try {
    const raw = fs.readFileSync(filePath, "utf8");
    return JSON.parse(raw);
  } catch {
    return fallback;
  }
}

function writeJsonFile(filePath, data) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
  fs.writeFileSync(filePath, `${JSON.stringify(data, null, 2)}\n`, "utf8");
}

function tryMakeDirWritable(dir) {
  try {
    fs.mkdirSync(dir, { recursive: true });
    const probe = path.join(dir, `.codemm-write-probe-${Date.now()}.txt`);
    fs.writeFileSync(probe, "ok", "utf8");
    fs.unlinkSync(probe);
    return true;
  } catch {
    return false;
  }
}

function hashWorkspaceDir(workspaceDir) {
  const normalized = path.resolve(workspaceDir);
  return crypto.createHash("sha256").update(normalized).digest("hex").slice(0, 16);
}

async function resolveWorkspace({ userDataDir }) {
  const prefsPath = path.join(userDataDir, "prefs.json");
  const prefs = readJsonFile(prefsPath, { v: 1, lastWorkspaceDir: null });

  const explicit = typeof process.env.CODEMM_WORKSPACE_DIR === "string" ? process.env.CODEMM_WORKSPACE_DIR.trim() : "";
  if (explicit) {
    const dir = path.resolve(explicit);
    writeJsonFile(prefsPath, { ...prefs, lastWorkspaceDir: dir });
    return { prefsPath, workspaceDir: dir };
  }

  if (prefs && typeof prefs.lastWorkspaceDir === "string" && prefs.lastWorkspaceDir.trim()) {
    const dir = path.resolve(prefs.lastWorkspaceDir);
    if (fs.existsSync(dir)) return { prefsPath, workspaceDir: dir };
  }

  const picked = await dialog.showOpenDialog({
    title: "Choose a workspace folder",
    properties: ["openDirectory", "createDirectory"],
    message: "Codemm stores threads and runs per workspace.",
  });
  if (picked.canceled || !picked.filePaths?.[0]) {
    return { prefsPath, workspaceDir: null };
  }

  const dir = path.resolve(picked.filePaths[0]);
  writeJsonFile(prefsPath, { ...prefs, lastWorkspaceDir: dir });
  return { prefsPath, workspaceDir: dir };
}

function resolveWorkspaceDataDir({ userDataDir, workspaceDir }) {
  const explicit =
    typeof process.env.CODEMM_WORKSPACE_DATA_DIR === "string"
      ? process.env.CODEMM_WORKSPACE_DATA_DIR.trim()
      : "";
  if (explicit) {
    const dir = path.isAbsolute(explicit) ? path.resolve(explicit) : path.resolve(workspaceDir, explicit);
    if (tryMakeDirWritable(dir)) return dir;
  }

  const local = path.join(workspaceDir, ".codemm");
  if (tryMakeDirWritable(local)) return local;

  const fallback = path.join(userDataDir, "Workspaces", hashWorkspaceDir(workspaceDir));
  fs.mkdirSync(fallback, { recursive: true });
  return fallback;
}

function resolveSecretsStorePath({ userDataDir }) {
  return path.join(userDataDir, "secrets.json");
}

function loadSecrets({ userDataDir }) {
  const secretsPath = resolveSecretsStorePath({ userDataDir });
  const data = readJsonFile(secretsPath, { v: 1, llm: null });
  if (!data || data.v !== 1) return { secretsPath, llm: null };
  const llm = data.llm;
  if (!llm || typeof llm !== "object") return { secretsPath, llm: null };

  const provider = typeof llm.provider === "string" ? llm.provider : null;
  const apiKeyEncB64 = typeof llm.apiKeyEncB64 === "string" ? llm.apiKeyEncB64 : null;
  const model = typeof llm.model === "string" ? llm.model : null;
  const updatedAt = typeof llm.updatedAt === "string" ? llm.updatedAt : null;
  if (!provider) return { secretsPath, llm: null };

  try {
    if (!apiKeyEncB64) {
      return { secretsPath, llm: { provider, apiKey: null, model, updatedAt } };
    }
    const buf = Buffer.from(apiKeyEncB64, "base64");
    const apiKey = safeStorage.decryptString(buf);
    return { secretsPath, llm: { provider, apiKey, model, updatedAt } };
  } catch {
    return { secretsPath, llm: null };
  }
}

function saveSecrets({ userDataDir, provider, apiKey, model }) {
  const secretsPath = resolveSecretsStorePath({ userDataDir });
  const nextModel = typeof model === "string" && model.trim() ? model.trim() : null;
  const nextApiKey = typeof apiKey === "string" && apiKey.trim() ? apiKey.trim() : null;
  const apiKeyEncB64 = (() => {
    if (!nextApiKey) return null;
    if (!safeStorage.isEncryptionAvailable()) {
      throw new Error("Electron safeStorage encryption is not available on this system.");
    }
    return safeStorage.encryptString(nextApiKey).toString("base64");
  })();
  const updatedAt = new Date().toISOString();
  writeJsonFile(secretsPath, { v: 1, llm: { provider, apiKeyEncB64, model: nextModel, updatedAt } });
  return { secretsPath, updatedAt };
}

function clearSecrets({ userDataDir }) {
  const secretsPath = resolveSecretsStorePath({ userDataDir });
  writeJsonFile(secretsPath, { v: 1, llm: null });
  return { secretsPath };
}

function waitForHttpOk(url, { timeoutMs = 120_000, intervalMs = 500 } = {}) {
  const deadline = Date.now() + timeoutMs;
  let lastLogAt = 0;

  async function once() {
    return new Promise((resolve) => {
      const req = http.get(url, (res) => {
        res.resume();
        resolve(res.statusCode && res.statusCode >= 200 && res.statusCode < 500);
      });
      req.on("error", () => resolve(false));
      req.setTimeout(2_000, () => {
        req.destroy();
        resolve(false);
      });
    });
  }

  return (async () => {
    while (Date.now() < deadline) {
      // Treat any HTTP response as "up" (even 404) because Next.js may respond with redirects/404s.
      if (await once()) return true;
      if (Date.now() - lastLogAt > 5000) {
        lastLogAt = Date.now();
        console.log(`[ide] Waiting for ${url}...`);
      }
      await sleep(intervalMs);
    }
    return false;
  })();
}

function waitForFrontendReady(frontendUrl, { token, timeoutMs = 180_000, intervalMs = 500 } = {}) {
  const healthUrl = `${frontendUrl}/codemm/health`;
  const deadline = Date.now() + timeoutMs;
  let lastLogAt = 0;

  async function once() {
    return new Promise((resolve) => {
      const req = http.get(healthUrl, (res) => {
        const chunks = [];
        res.on("data", (c) => chunks.push(c));
        res.on("end", () => {
          const code = res.statusCode ?? 0;
          if (code < 200 || code >= 300) return resolve(false);
          try {
            const raw = Buffer.concat(chunks).toString("utf8");
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") return resolve(false);
            if (parsed.ok !== true) return resolve(false);
            if (typeof token === "string" && token) {
              return resolve(parsed.token === token);
            }
            return resolve(true);
          } catch {
            return resolve(false);
          }
        });
        res.on("error", () => resolve(false));
      });
      req.on("error", () => resolve(false));
      req.setTimeout(2_000, () => {
        req.destroy();
        resolve(false);
      });
    });
  }

  return (async () => {
    while (Date.now() < deadline) {
      if (await once()) return true;
      if (Date.now() - lastLogAt > 5000) {
        lastLogAt = Date.now();
        console.log(`[ide] Waiting for frontend health: ${healthUrl}...`);
      }
      await sleep(intervalMs);
    }
    return false;
  })();
}

function existsExecutable(p) {
  try {
    const stat = fs.statSync(p);
    if (!stat.isFile()) return false;
    // On Windows, X_OK isn't reliable; existence + file-ness is good enough for our use.
    if (process.platform === "win32") return true;
    fs.accessSync(p, fs.constants.X_OK);
    return true;
  } catch {
    return false;
  }
}

function commandExists(cmd, args = ["--version"]) {
  const res = spawnSync(cmd, args, { stdio: "ignore" });
  if (res.error && res.error.code === "ENOENT") return false;
  return res.status === 0;
}

function httpGetJson(url, { timeoutMs = 2000 } = {}) {
  return new Promise((resolve, reject) => {
    const req = http.get(url, (res) => {
      const chunks = [];
      res.on("data", (c) => chunks.push(c));
      res.on("end", () => {
        const code = res.statusCode ?? 0;
        if (code < 200 || code >= 300) return reject(new Error(`HTTP ${code}`));
        try {
          const raw = Buffer.concat(chunks).toString("utf8");
          resolve(JSON.parse(raw));
        } catch (e) {
          reject(e);
        }
      });
      res.on("error", reject);
    });
    req.on("error", reject);
    req.setTimeout(timeoutMs, () => {
      req.destroy(new Error("timeout"));
    });
  });
}

function findDockerBinary() {
  if (process.env.DOCKER_PATH && existsExecutable(process.env.DOCKER_PATH)) {
    return process.env.DOCKER_PATH;
  }

  /** @type {string[]} */
  const candidates = [];

  // PATH first (but only if it actually resolves).
  if (commandExists("docker", ["--version"])) candidates.push("docker");

  if (process.platform === "darwin") {
    candidates.push(
      "/usr/local/bin/docker",
      "/opt/homebrew/bin/docker",
      "/Applications/Docker.app/Contents/Resources/bin/docker"
    );
  } else if (process.platform === "win32") {
    candidates.push(
      "C:\\\\Program Files\\\\Docker\\\\Docker\\\\resources\\\\bin\\\\docker.exe",
      "C:\\\\Program Files\\\\Docker\\\\Docker\\\\resources\\\\bin\\\\docker"
    );
  } else {
    // linux + other unix
    candidates.push("/usr/bin/docker", "/usr/local/bin/docker", "/snap/bin/docker");
  }

  for (const c of candidates) {
    if (c === "docker") return "docker";
    if (existsExecutable(c)) return c;
  }

  return null;
}

function findOllamaBinary() {
  if (process.env.OLLAMA_PATH && existsExecutable(process.env.OLLAMA_PATH)) {
    return process.env.OLLAMA_PATH;
  }

  /** @type {string[]} */
  const candidates = [];

  if (commandExists("ollama", ["--version"])) candidates.push("ollama");

  if (process.platform === "darwin") {
    candidates.push("/usr/local/bin/ollama", "/opt/homebrew/bin/ollama");
  } else if (process.platform === "win32") {
    const localAppData = process.env.LOCALAPPDATA || path.join(os.homedir(), "AppData", "Local");
    candidates.push(
      path.join(localAppData, "Programs", "Ollama", "ollama.exe"),
      "C:\\\\Program Files\\\\Ollama\\\\ollama.exe"
    );
  } else {
    candidates.push("/usr/bin/ollama", "/usr/local/bin/ollama");
  }

  for (const c of candidates) {
    if (c === "ollama") return "ollama";
    if (existsExecutable(c)) return c;
  }

  return null;
}

async function getOllamaStatus({ baseURL = OLLAMA_DEFAULT_URL, model = null } = {}) {
  const base = String(baseURL || OLLAMA_DEFAULT_URL).replace(/\/+$/, "");
  const ollamaBin = findOllamaBinary();
  const installed = Boolean(ollamaBin);

  let running = false;
  let version = null;
  let models = null;
  let modelPresent = null;
  let lastError = null;

  try {
    const v = await httpGetJson(`${base}/api/version`, { timeoutMs: 1500 });
    running = true;
    version = v && typeof v.version === "string" ? v.version : null;
  } catch (e) {
    lastError = e?.message ? String(e.message) : "not running";
  }

  if (running) {
    try {
      const tags = await httpGetJson(`${base}/api/tags`, { timeoutMs: 3000 });
      const arr = Array.isArray(tags?.models) ? tags.models : [];
      const names = arr
        .map((m) => (m && typeof m.name === "string" ? m.name : null))
        .filter((x) => typeof x === "string");
      models = names;
      if (typeof model === "string" && model.trim()) {
        modelPresent = names.includes(model.trim());
      }
    } catch (e) {
      lastError = e?.message ? String(e.message) : "failed to list models";
    }
  }

  return {
    baseURL: base,
    installed,
    running,
    version,
    models,
    modelPresent,
    error: lastError,
    ollamaBin,
  };
}

async function startOllamaServe(ollamaBin, { baseURL = OLLAMA_DEFAULT_URL } = {}) {
  const base = String(baseURL || OLLAMA_DEFAULT_URL).replace(/\/+$/, "");
  const proc = spawn(ollamaBin, ["serve"], { detached: true, stdio: "ignore", windowsHide: true });
  proc.unref();

  const deadline = Date.now() + 12_000;
  while (Date.now() < deadline) {
    try {
      await httpGetJson(`${base}/api/version`, { timeoutMs: 1200 });
      return { ok: true };
    } catch {
      await sleep(500);
    }
  }
  return { ok: false, reason: "Timed out waiting for Ollama to start." };
}

function checkDockerRunning({ dockerBin, timeoutMs = 8000 }) {
  const res = spawnSync(dockerBin, ["info"], {
    stdio: "pipe",
    timeout: timeoutMs,
    encoding: "utf8",
  });

  if (res.error && res.error.code === "ENOENT") {
    return { ok: false, reason: `Docker binary not found: ${dockerBin}` };
  }
  if (res.error && res.error.code === "ETIMEDOUT") {
    return { ok: false, reason: `Timed out after ${timeoutMs}ms while running "docker info".` };
  }

  if (res.status === 0) return { ok: true, reason: "" };

  const detail = String((res.stderr || res.stdout || "")).trim();
  return {
    ok: false,
    reason: detail || `docker info exited with code ${String(res.status)}`,
  };
}

async function waitForDockerRunning({
  dockerBin,
  totalTimeoutMs = 180_000,
  tryTimeoutMs = 8_000,
  intervalMs = 2_000,
} = {}) {
  const deadline = Date.now() + totalTimeoutMs;
  let lastLogAt = 0;
  /** @type {string} */
  let lastReason = "Not checked yet";

  while (Date.now() < deadline) {
    const r = checkDockerRunning({ dockerBin, timeoutMs: tryTimeoutMs });
    if (r.ok) return { ok: true, reason: "" };
    lastReason = r.reason;

    if (Date.now() - lastLogAt > 5000) {
      lastLogAt = Date.now();
      console.log(`[ide] Docker not ready yet; retrying... (${lastReason})`);
    }

    await sleep(intervalMs);
  }

  return { ok: false, reason: lastReason };
}

function killProcessTree(proc) {
  if (!proc || !proc.pid) return;
  if (process.platform === "win32") {
    try {
      spawnSync("taskkill", ["/pid", String(proc.pid), "/T", "/F"], { stdio: "ignore" });
      return;
    } catch {
      // fallthrough
    }
  }
  try {
    // On macOS/Linux, negative PID targets the full process group when spawned with `detached: true`.
    process.kill(-proc.pid, "SIGTERM");
  } catch {
    try {
      proc.kill("SIGTERM");
    } catch {
      // ignore
    }
  }
}

function wireLogs(name, proc) {
  if (!proc) return;
  proc.stdout?.on("data", (buf) => process.stdout.write(`[${name}] ${buf}`));
  proc.stderr?.on("data", (buf) => process.stderr.write(`[${name}] ${buf}`));
}

function isObject(x) {
  return Boolean(x) && typeof x === "object" && !Array.isArray(x);
}

function validate(schema, args) {
  const res = schema.safeParse(args);
  if (!res.success) {
    const msg = res.error.issues?.[0]?.message || "Invalid args.";
    const err = new Error(msg);
    err.name = "ValidationError";
    throw err;
  }
  return res.data;
}

function resolveNodeBin() {
  const override = typeof process.env.CODEMM_NODE_BIN === "string" ? process.env.CODEMM_NODE_BIN.trim() : "";
  return override || "node";
}

function spawnSystemNode(scriptPath, args, { cwd, env, stdio }) {
  const nodeBin = resolveNodeBin();
  return spawn(nodeBin, [scriptPath, ...(args || [])], {
    cwd,
    env,
    detached: true,
    stdio,
    windowsHide: true,
  });
}

function spawnNodeWithElectron(scriptPath, args, { cwd, env, stdio }) {
  return spawn(process.execPath, [scriptPath, ...(args || [])], {
    cwd,
    env: { ...env, ELECTRON_RUN_AS_NODE: "1" },
    detached: true,
    stdio,
    windowsHide: true,
  });
}

function startEngineIpc({ backendDir, env, onEvent }) {
  const entry = path.join(backendDir, "ipc-server.js");
  if (!fs.existsSync(entry)) {
    throw new Error(`Engine IPC entry not found: ${entry}`);
  }

  const proc = (app.isPackaged ? spawnNodeWithElectron : spawnSystemNode)(entry, [], {
    cwd: backendDir,
    env,
    stdio: ["ignore", "pipe", "pipe", "ipc"],
  });
  proc.unref();
  wireLogs("engine", proc);

  const pending = new Map();

  const rejectAll = (reason) => {
    for (const { reject, timeout } of pending.values()) {
      clearTimeout(timeout);
      reject(reason);
    }
    pending.clear();
  };

  proc.on("message", (raw) => {
    if (!isObject(raw)) return;
    if (raw.type === "res" && typeof raw.id === "string") {
      const p = pending.get(raw.id);
      if (!p) return;
      pending.delete(raw.id);
      clearTimeout(p.timeout);
      if (raw.ok === true) p.resolve(raw.result);
      else p.reject(new Error(raw?.error?.message || "Engine error."));
      return;
    }
    if (raw.type === "event") {
      try {
        onEvent(raw);
      } catch {
        // ignore
      }
    }
  });

  proc.on("exit", (code) => {
    rejectAll(new Error(`Engine exited (code=${code ?? "unknown"}).`));
  });
  proc.on("error", (err) => {
    rejectAll(err instanceof Error ? err : new Error(String(err)));
  });

  function call(method, params) {
    if (!proc || !proc.connected) {
      return Promise.reject(new Error("Engine not connected."));
    }
    const id = crypto.randomUUID();
    const timeout = setTimeout(() => {
      const p = pending.get(id);
      if (!p) return;
      pending.delete(id);
      p.reject(new Error(`Engine RPC timed out for method "${method}".`));
    }, 10 * 60_000);

    const p = new Promise((resolve, reject) => {
      pending.set(id, { resolve, reject, timeout });
    });
    proc.send({ id, type: "req", method, params: params ?? {} });
    return p;
  }

  function shutdown() {
    rejectAll(new Error("Engine shutdown."));
    killProcessTree(proc);
  }

  return { proc, call, shutdown };
}

function requireEngine() {
  if (!engine) throw new Error("Engine unavailable. Restart the IDE.");
  return engine;
}

async function pickAvailablePort(preferredPort) {
  const shouldSkipHost = (err) => {
    const code = err && typeof err === "object" ? err.code : null;
    // Some environments may not have IPv6 loopback enabled; don't block dev boot on that.
    return code === "EAFNOSUPPORT" || code === "EADDRNOTAVAIL";
  };

  const tryListen = (port, host) =>
    new Promise((resolve, reject) => {
      const s = net.createServer();
      s.unref();
      s.on("error", reject);
      s.listen({ port, host }, () => {
        const addr = s.address();
        const chosen = addr && typeof addr === "object" ? addr.port : port;
        s.close(() => resolve(chosen));
      });
    });

  const isPortFree = async (port) => {
    // Next may bind on IPv6 (::) depending on flags/env, so we probe both loopbacks.
    const hosts = ["127.0.0.1", "::1"];
    for (const host of hosts) {
      try {
        await tryListen(port, host);
      } catch (err) {
        if (host === "::1" && shouldSkipHost(err)) continue;
        return false;
      }
    }
    return true;
  };

  if (await isPortFree(preferredPort)) return preferredPort;

  // Pick an ephemeral port and confirm it's usable on the loopback(s) we care about.
  for (let i = 0; i < 10; i += 1) {
    const candidate = await tryListen(0, "127.0.0.1");
    if (await isPortFree(candidate)) return candidate;
  }

  // Fall back to "any ephemeral port" even if IPv6 probing is inconclusive.
  return await tryListen(0, "127.0.0.1");
}

function materializeJudgeBuildContext({ backendDir, userDataDir }) {
  if (!app.isPackaged) return backendDir;

  const outDir = path.join(userDataDir, "judge-context");
  try {
    fs.rmSync(outDir, { recursive: true, force: true });
  } catch {
    // ignore
  }
  fs.mkdirSync(outDir, { recursive: true });

  const files = [
    "Dockerfile.java-judge",
    "Dockerfile.python-judge",
    "Dockerfile.cpp-judge",
    "Dockerfile.sql-judge",
  ];

  for (const f of files) {
    fs.copyFileSync(path.join(backendDir, f), path.join(outDir, f));
  }

  // SQL judge Dockerfile copies this file from the build context.
  const sqlRunnerSrc = path.join(backendDir, "src", "languages", "sql", "judgeRunner.py");
  const sqlRunnerDest = path.join(outDir, "src", "languages", "sql", "judgeRunner.py");
  fs.mkdirSync(path.dirname(sqlRunnerDest), { recursive: true });
  fs.copyFileSync(sqlRunnerSrc, sqlRunnerDest);

  return outDir;
}

async function ensureNodeModules({ dir, label, env }) {
  const nm = path.join(dir, "node_modules");
  if (fs.existsSync(nm)) {
    console.log(`[ide] ${label}: node_modules present, skipping npm install`);
    return true;
  }

  console.log(`[ide] ${label}: installing npm dependencies...`);
  const child = spawn(getNpmBin(), ["install"], {
    cwd: dir,
    env,
    stdio: ["ignore", "pipe", "pipe"],
  });
  wireLogs(`${label}:npm`, child);

  const code = await new Promise((resolve) => {
    child.on("exit", (c) => resolve(c));
    child.on("error", () => resolve(1));
  });

  return code === 0;
}

async function spawnAndWait(name, cmd, args, { cwd, env }) {
  const child = spawn(cmd, args, {
    cwd,
    env,
    stdio: ["ignore", "pipe", "pipe"],
  });
  wireLogs(name, child);

  const code = await new Promise((resolve) => {
    child.on("exit", (c) => resolve(typeof c === "number" ? c : 1));
    child.on("error", () => resolve(1));
  });
  return code;
}

async function ensureJudgeImages({ dockerBin, backendDir, env }) {
  const rebuild = process.env.CODEMM_REBUILD_JUDGE === "1";
  const images = [
    { image: "codem-java-judge", dockerfile: "Dockerfile.java-judge" },
    { image: "codem-python-judge", dockerfile: "Dockerfile.python-judge" },
    { image: "codem-cpp-judge", dockerfile: "Dockerfile.cpp-judge" },
    { image: "codem-sql-judge", dockerfile: "Dockerfile.sql-judge" },
  ];

  for (const { image, dockerfile } of images) {
    if (rebuild) {
      console.log(`[ide] Rebuilding judge image: ${image}`);
      spawnSync(dockerBin, ["image", "rm", "-f", `${image}:latest`], { stdio: "ignore" });
    }

    const exists =
      spawnSync(dockerBin, ["image", "inspect", `${image}:latest`], { stdio: "ignore" }).status ===
      0;

    if (exists && !rebuild) {
      console.log(`[ide] Judge image found: ${image}`);
      continue;
    }

    console.log(`[ide] Building judge image: ${image} (from ${dockerfile})...`);
    const code = await spawnAndWait(
      `docker:${image}`,
      dockerBin,
      ["build", "--progress=plain", "-f", dockerfile, "-t", image, "."],
      { cwd: backendDir, env },
    );
    if (code !== 0) return false;
  }

  return true;
}

async function createWindowAndBoot() {
  const storage = configureElectronStoragePaths();
  console.log(`[ide] userDataDir=${storage.userDataDir}`);
  console.log(`[ide] cacheDir=${storage.cacheDir}`);

  // __dirname = apps/ide
  const repoRoot = path.resolve(__dirname, "..", "..");
  const backendDir =
    process.env.CODEMM_BACKEND_DIR || path.join(repoRoot, "apps", "backend");
  const frontendDir =
    process.env.CODEMM_FRONTEND_DIR || path.join(repoRoot, "apps", "frontend");

  console.log(`[ide] repoRoot=${repoRoot}`);
  console.log(`[ide] backendDir=${backendDir}`);
  console.log(`[ide] frontendDir=${frontendDir}`);

  // Dev ergonomics: default the workspace to the repo root (so `.codemm/` doesn't end up
  // in a parent folder like "Documents"). Developers can override with CODEMM_WORKSPACE_DIR,
  // or use the workspace chooser IPC later.
  if (!app.isPackaged && !process.env.CODEMM_WORKSPACE_DIR) {
    process.env.CODEMM_WORKSPACE_DIR = repoRoot;
  }

  const dockerBin = findDockerBinary();
  if (!dockerBin) {
    dialog.showErrorBox(
      "Docker Not Found",
      [
        "Codemm requires Docker for judging (/run and /submit).",
        "Install Docker Desktop and ensure `docker` is available in your PATH,",
        "or set DOCKER_PATH to the docker binary.",
      ].join("\n"),
    );
    app.quit();
    return;
  }
  console.log(`[ide] dockerBin=${dockerBin}`);

  console.log('[ide] Checking Docker ("docker info")...');
  const dockerCheck = await waitForDockerRunning({ dockerBin });
  if (!dockerCheck.ok) {
    dialog.showErrorBox(
      "Docker Not Running",
      [
        "Codemm requires Docker for judging.",
        "Start Docker Desktop, wait until it's running, then relaunch Codemm-Desktop.",
        "",
        `Details: ${dockerCheck.reason}`,
      ].join("\n"),
    );
    app.quit();
    return;
  }
  console.log("[ide] Docker is running");

  const workspaceResolution = await resolveWorkspace({ userDataDir: storage.userDataDir });
  if (!workspaceResolution.workspaceDir) {
    dialog.showErrorBox("No Workspace Selected", "Codemm-Desktop needs a workspace folder to store threads and runs.");
    app.quit();
    return;
  }

  const workspaceDir = workspaceResolution.workspaceDir;
  const workspaceDataDir = resolveWorkspaceDataDir({ userDataDir: storage.userDataDir, workspaceDir });
  const backendDbPath = path.join(workspaceDataDir, "codemm.db");
  currentWorkspace = { workspaceDir, workspaceDataDir, backendDbPath, userDataDir: storage.userDataDir };

  console.log(`[ide] workspaceDir=${workspaceDir}`);
  console.log(`[ide] workspaceDataDir=${workspaceDataDir}`);
  console.log(`[ide] backendDbPath=${backendDbPath}`);

  if (!ipcWired) {
    ipcWired = true;

    ipcMain.handle("codemm:workspace:get", () => {
      if (!currentWorkspace) return null;
      return { workspaceDir: currentWorkspace.workspaceDir, workspaceDataDir: currentWorkspace.workspaceDataDir };
    });

    ipcMain.handle("codemm:workspace:choose", async () => {
      const r = await resolveWorkspace({ userDataDir: storage.userDataDir });
      if (!r.workspaceDir) return { ok: false, error: "Workspace selection canceled." };
      const nextWorkspaceDir = r.workspaceDir;
      const nextWorkspaceDataDir = resolveWorkspaceDataDir({ userDataDir: storage.userDataDir, workspaceDir: nextWorkspaceDir });
      const nextBackendDbPath = path.join(nextWorkspaceDataDir, "codemm.db");
      currentWorkspace = { workspaceDir: nextWorkspaceDir, workspaceDataDir: nextWorkspaceDataDir, backendDbPath: nextBackendDbPath, userDataDir: storage.userDataDir };
      dialog.showMessageBox({
        type: "info",
        message: "Workspace changed",
        detail: "Restart Codemm-Desktop to apply the new workspace.",
      }).catch(() => {});
      return { ok: true, workspaceDir: nextWorkspaceDir, workspaceDataDir: nextWorkspaceDataDir };
    });

    ipcMain.handle("codemm:secrets:getLlmSettings", () => {
      const { llm } = loadSecrets({ userDataDir: storage.userDataDir });
      const isOllama = llm && String(llm.provider || "").toLowerCase() === "ollama";
      return {
        configured: Boolean(llm && (llm.apiKey || (isOllama && llm.model))),
        provider: llm ? llm.provider : null,
        model: llm ? llm.model ?? null : null,
        updatedAt: llm ? llm.updatedAt ?? null : null,
      };
    });

    ipcMain.handle("codemm:secrets:setLlmSettings", async (_evt, args) => {
      const parsed = validate(
        z.object({
          provider: z.enum(["openai", "anthropic", "gemini", "ollama"]),
          apiKey: z.string().min(10).max(500).optional(),
          model: z.string().min(1).max(128).optional(),
        }),
        args
      );
      const provider = parsed.provider.trim().toLowerCase();
      const apiKey = typeof parsed.apiKey === "string" ? parsed.apiKey.trim() : "";
      const model = typeof parsed.model === "string" ? parsed.model.trim() : "";
      if (!(provider === "openai" || provider === "anthropic" || provider === "gemini" || provider === "ollama")) {
        throw new Error("Invalid provider.");
      }
      if (provider === "ollama") {
        if (!model) throw new Error("Model is required for Ollama.");
      } else {
        if (!apiKey || apiKey.length < 10) throw new Error("API key is required.");
      }

      const { updatedAt } = saveSecrets({
        userDataDir: storage.userDataDir,
        provider,
        ...(provider === "ollama" ? { apiKey: null, model } : { apiKey, model: null }),
      });
      // Apply to running engine (best-effort); do not expose secrets to renderer JS.
      try {
        if (engine) {
          await requireEngine().call("engine.configureLlm", {
            provider,
            apiKey: provider === "ollama" ? null : apiKey,
            model: provider === "ollama" ? model : null,
            baseURL: provider === "ollama" ? OLLAMA_DEFAULT_URL : null,
          });
        }
      } catch (e) {
        console.warn("[ide] Failed to apply LLM settings to running engine (restart may be required):", e?.message || e);
      }
      dialog.showMessageBox({
        type: "info",
        message: "LLM settings saved",
        detail: "Applied to the local engine. Existing runs keep their original provider configuration.",
      }).catch(() => {});
      return { ok: true, updatedAt };
    });

    ipcMain.handle("codemm:secrets:clearLlmSettings", async () => {
      clearSecrets({ userDataDir: storage.userDataDir });
      try {
        if (engine) {
          await requireEngine().call("engine.configureLlm", { provider: null, apiKey: null, model: null, baseURL: null });
        }
      } catch (e) {
        console.warn("[ide] Failed to clear running engine LLM config (restart may be required):", e?.message || e);
      }
      dialog.showMessageBox({
        type: "info",
        message: "LLM settings cleared",
        detail: "Applied to the local engine. Existing runs keep their original provider configuration.",
      }).catch(() => {});
      return { ok: true };
    });

    // Ollama helpers (local-only).
    const ollamaPullSubs = new Map(); // subId -> { buffered: any[], proc: import("child_process").ChildProcess|null }

    const sendOllamaEvent = (subId, event) => {
      const sub = ollamaPullSubs.get(subId);
      if (!sub) return;
      sub.buffered.push(event);
      if (sub.buffered.length > 200) sub.buffered.shift();
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send("codemm:ollama:pullEvent", { subId, event });
      }
    };

    const ensureSafeModelName = (raw) => {
      const s = typeof raw === "string" ? raw.trim() : "";
      if (!s) return null;
      if (s.length > 128) throw new Error("Model name is too long.");
      if (/\s/.test(s)) throw new Error("Model name must not contain whitespace.");
      return s;
    };

    async function startOllamaPull({ model, baseURL, subId }) {
      const ollamaBin = findOllamaBinary();
      if (!ollamaBin) throw new Error("Ollama is not installed.");
      sendOllamaEvent(subId, { type: "status", message: `Pulling model \"${model}\"…` });
      const proc = spawn(ollamaBin, ["pull", model], { stdio: ["ignore", "pipe", "pipe"], windowsHide: true });
      const sub = ollamaPullSubs.get(subId);
      if (sub) sub.proc = proc;

      const forward = (stream, buf) => {
        const text = String(buf ?? "");
        if (!text) return;
        sendOllamaEvent(subId, { type: "log", stream, text });
      };
      proc.stdout?.on("data", (b) => forward("stdout", b));
      proc.stderr?.on("data", (b) => forward("stderr", b));
      proc.on("close", async (code) => {
        sendOllamaEvent(subId, { type: "done", code: typeof code === "number" ? code : null });
        try {
          const st = await getOllamaStatus({ baseURL, model });
          sendOllamaEvent(subId, { type: "status", message: st.modelPresent ? "Model is ready." : "Pull finished." });
        } catch {
          // ignore
        }
      });
    }

    ipcMain.handle("codemm:ollama:getStatus", async (_evt, args) => {
      const parsed = validate(
        z
          .object({
            model: z.string().min(1).max(128).optional(),
            baseURL: z.string().min(1).max(256).optional(),
          })
          .optional(),
        args
      );
      const model = ensureSafeModelName(parsed?.model ?? null);
      const baseURL = typeof parsed?.baseURL === "string" ? parsed.baseURL.trim() : OLLAMA_DEFAULT_URL;
      const st = await getOllamaStatus({ baseURL, model });
      return {
        installed: st.installed,
        running: st.running,
        version: st.version,
        baseURL: st.baseURL,
        model,
        modelPresent: st.modelPresent,
        models: st.models,
        error: st.error,
      };
    });

    ipcMain.handle("codemm:ollama:ensure", async (_evt, args) => {
      const parsed = validate(
        z.object({
          model: z.string().min(1).max(128),
          baseURL: z.string().min(1).max(256).optional(),
        }),
        args
      );
      const model = ensureSafeModelName(parsed.model);
      const baseURL = typeof parsed.baseURL === "string" ? parsed.baseURL.trim() : OLLAMA_DEFAULT_URL;
      if (!model) throw new Error("Model is required.");

      const st0 = await getOllamaStatus({ baseURL, model });
      if (!st0.installed) return { ok: false, reason: "OLLAMA_NOT_INSTALLED" };

      if (!st0.running) {
        const bin = findOllamaBinary();
        if (!bin) return { ok: false, reason: "OLLAMA_NOT_INSTALLED" };
        const started = await startOllamaServe(bin, { baseURL });
        if (!started.ok) return { ok: false, reason: "OLLAMA_START_FAILED", detail: started.reason };
      }

      const st1 = await getOllamaStatus({ baseURL, model });
      if (st1.modelPresent) {
        return { ok: true, pulling: false, status: { ...st1, ollamaBin: undefined } };
      }

      const subId = crypto.randomUUID();
      ollamaPullSubs.set(subId, { buffered: [], proc: null });
      sendOllamaEvent(subId, { type: "status", message: "Starting model pull…" });
      startOllamaPull({ model, baseURL, subId }).catch((e) => {
        sendOllamaEvent(subId, { type: "error", message: e?.message || "Pull failed." });
        sendOllamaEvent(subId, { type: "done", code: null });
      });
      return { ok: true, pulling: true, subId, buffered: ollamaPullSubs.get(subId)?.buffered ?? [] };
    });

    ipcMain.handle("codemm:ollama:unsubscribePull", async (_evt, args) => {
      const parsed = validate(z.object({ subId: z.string().min(1).max(128) }), args);
      const subId = reqString(parsed.subId, "subId");
      const sub = ollamaPullSubs.get(subId);
      if (sub && sub.proc) {
        try {
          killProcessTree(sub.proc);
        } catch {
          // ignore
        }
      }
      ollamaPullSubs.delete(subId);
      return { ok: true };
    });

    const reqString = (v, name) => {
      const s = typeof v === "string" ? v.trim() : "";
      if (!s) throw new Error(`${name} is required.`);
      return s;
    };

    const engineCall = (method, params) => requireEngine().call(method, params);

    // Threads (local-only; no HTTP boundary).
    ipcMain.handle("codemm:threads:create", async (_evt, args) => {
      const parsed = validate(
        z
          .object({
            learning_mode: z.enum(["practice", "guided"]).optional(),
          })
          .optional(),
        args
      );
      const learning_mode = parsed?.learning_mode ?? null;
      return engineCall("threads.create", { ...(learning_mode ? { learning_mode } : {}) });
    });

    ipcMain.handle("codemm:threads:list", async (_evt, args) => {
      const parsed = validate(
        z
          .object({
            limit: z.number().int().min(1).max(200).optional(),
          })
          .optional(),
        args
      );
      const limit = typeof parsed?.limit === "number" ? parsed.limit : 30;
      return engineCall("threads.list", { limit });
    });

    ipcMain.handle("codemm:threads:get", async (_evt, args) => {
      const parsed = validate(z.object({ threadId: z.string().min(1).max(128) }), args);
      const threadId = reqString(parsed.threadId, "threadId");
      return engineCall("threads.get", { threadId });
    });

    ipcMain.handle("codemm:threads:setInstructions", async (_evt, args) => {
      const parsed = validate(
        z.object({
          threadId: z.string().min(1).max(128),
          instructions_md: z.string().max(8000).nullable(),
        }),
        args
      );
      const threadId = reqString(parsed.threadId, "threadId");
      return engineCall("threads.setInstructions", { threadId, instructions_md: parsed.instructions_md });
    });

    ipcMain.handle("codemm:threads:postMessage", async (_evt, args) => {
      const parsed = validate(
        z.object({
          threadId: z.string().min(1).max(128),
          message: z.string().min(1).max(50_000),
        }),
        args
      );
      const threadId = reqString(parsed.threadId, "threadId");
      const message = reqString(parsed.message, "message");
      if (message.length > 50_000) throw new Error("message is too large.");
      return engineCall("threads.postMessage", { threadId, message });
    });

    ipcMain.handle("codemm:threads:generate", async (_evt, args) => {
      const parsed = validate(z.object({ threadId: z.string().min(1).max(128) }), args);
      const threadId = reqString(parsed.threadId, "threadId");
      return engineCall("threads.generate", { threadId });
    });

    ipcMain.handle("codemm:threads:subscribeGeneration", async (_evt, args) => {
      const parsed = validate(z.object({ threadId: z.string().min(1).max(128) }), args);
      const threadId = reqString(parsed.threadId, "threadId");
      return engineCall("threads.subscribeGeneration", { threadId });
    });

    ipcMain.handle("codemm:threads:unsubscribeGeneration", async (_evt, args) => {
      const parsed = validate(z.object({ subId: z.string().min(1).max(128) }), args);
      const subId = reqString(parsed.subId, "subId");
      return engineCall("threads.unsubscribeGeneration", { subId });
    });

    // Activities
    ipcMain.handle("codemm:activities:list", async (_evt, args) => {
      const parsed = validate(
        z
          .object({
            limit: z.number().int().min(1).max(200).optional(),
          })
          .optional(),
        args
      );
      const limit = typeof parsed?.limit === "number" ? parsed.limit : 30;
      return engineCall("activities.list", { limit });
    });

    ipcMain.handle("codemm:activities:get", async (_evt, args) => {
      const parsed = validate(z.object({ id: z.string().min(1).max(128) }), args);
      const id = reqString(parsed.id, "id");
      return engineCall("activities.get", { id });
    });

    ipcMain.handle("codemm:activities:patch", async (_evt, args) => {
      const parsed = validate(
        z.object({
          id: z.string().min(1).max(128),
          title: z.string().max(200).optional(),
          timeLimitSeconds: z.number().int().min(0).max(8 * 60 * 60).nullable().optional(),
        }),
        args
      );
      const id = reqString(parsed.id, "id");
      const title = typeof parsed.title === "string" ? parsed.title : undefined;
      const timeLimitSeconds = typeof parsed.timeLimitSeconds !== "undefined" ? parsed.timeLimitSeconds : undefined;
      return engineCall("activities.patch", { id, ...(typeof title !== "undefined" ? { title } : {}), ...(typeof timeLimitSeconds !== "undefined" ? { timeLimitSeconds } : {}) });
    });

    ipcMain.handle("codemm:activities:publish", async (_evt, args) => {
      const parsed = validate(z.object({ id: z.string().min(1).max(128) }), args);
      const id = reqString(parsed.id, "id");
      return engineCall("activities.publish", { id });
    });

    ipcMain.handle("codemm:activities:aiEdit", async (_evt, args) => {
      const parsed = validate(
        z.object({
          id: z.string().min(1).max(128),
          problemId: z.string().min(1).max(128),
          instruction: z.string().min(1).max(8_000),
        }),
        args
      );
      const id = reqString(parsed.id, "id");
      const problemId = reqString(parsed.problemId, "problemId");
      const instruction = reqString(parsed.instruction, "instruction");
      if (instruction.length > 8_000) throw new Error("instruction is too large.");
      return engineCall("activities.aiEdit", { id, problemId, instruction });
    });

    // Judge (Docker-backed)
    ipcMain.handle("codemm:judge:run", async (_evt, args) => {
      const parsed = validate(
        z
          .object({
            language: z.enum(["java", "python", "cpp", "sql"]),
            code: z.string().min(1).max(200_000).optional(),
            files: z.record(z.string(), z.string()).optional(),
            mainClass: z.string().min(1).max(256).optional(),
            stdin: z.string().max(50_000).optional(),
          })
          .refine((v) => Boolean(v.code) !== Boolean(v.files), { message: 'Provide either "code" or "files".' }),
        args
      );
      // Engine performs deeper validation and Docker sandboxing; main validates shapes + sizes only.
      return engineCall("judge.run", parsed);
    });

    ipcMain.handle("codemm:judge:submit", async (_evt, args) => {
      const parsed = validate(
        z
          .object({
            language: z.enum(["java", "python", "cpp", "sql"]).optional(),
            testSuite: z.string().min(1).max(200_000),
            code: z.string().min(1).max(200_000).optional(),
            files: z.record(z.string(), z.string()).optional(),
            activityId: z.string().min(1).max(128).optional(),
            problemId: z.string().min(1).max(128).optional(),
          })
          .refine((v) => Boolean(v.code) !== Boolean(v.files), { message: 'Provide either "code" or "files".' }),
        args
      );
      return engineCall("judge.submit", parsed);
    });
  }

  const frontendUrlHint = `http://127.0.0.1:${DEFAULT_FRONTEND_PORT}`;
  console.log(`[ide] frontendUrlHint=${frontendUrlHint}`);

  const win = new BrowserWindow({
    width: 1320,
    height: 860,
    show: true,
    backgroundColor: "#0b1220",
    webPreferences: {
      preload: path.join(__dirname, "preload.js"),
      nodeIntegration: false,
      contextIsolation: true,
    },
  });
  mainWindow = win;
  win.on("closed", () => {
    mainWindow = null;
  });

  // Deny all permission requests by default (camera/mic/notifications/etc).
  try {
    win.webContents.session.setPermissionRequestHandler((_wc, _permission, callback) => callback(false));
  } catch {
    // ignore
  }

  // Hard block popups; if the UI needs external links, we can explicitly open them with `shell.openExternal`.
  win.webContents.setWindowOpenHandler(({ url }) => {
    // If this is an external URL, open it in the user's browser.
    if (url && /^https?:\/\//.test(url)) {
      shell.openExternal(url).catch(() => {});
    }
    return { action: "deny" };
  });

  // Prevent navigations away from the expected local frontend origin.
  // The allowed origin is set once the frontend port is chosen.
  let allowedFrontendOrigin = null;
  const maybeBlockNavigation = (e, url) => {
    try {
      if (typeof url !== "string" || !url) return;
      if (url.startsWith("data:text/html")) return;
      if (!allowedFrontendOrigin) return;
      const u = new URL(url);
      if (u.origin === allowedFrontendOrigin) return;
      e.preventDefault();
      if (/^https?:\/\//.test(url)) {
        shell.openExternal(url).catch(() => {});
      }
    } catch {
      e.preventDefault();
    }
  };
  win.webContents.on("will-navigate", maybeBlockNavigation);
  win.webContents.on("will-redirect", maybeBlockNavigation);

  win.loadURL(
    `data:text/html;charset=utf-8,${encodeURIComponent(`
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <title>Codemm-Desktop</title>
          <style>
            html, body { height: 100%; margin: 0; }
            body {
              font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
              background: radial-gradient(1200px 800px at 20% 10%, #172554 0%, #0b1220 55%, #050814 100%);
              color: #e2e8f0;
              display: grid;
              place-items: center;
            }
            .card {
              width: min(720px, calc(100vw - 40px));
              border: 1px solid rgba(148, 163, 184, 0.18);
              background: rgba(2, 6, 23, 0.45);
              border-radius: 16px;
              padding: 22px 22px;
              box-shadow: 0 24px 80px rgba(0,0,0,0.45);
            }
            h1 { font-size: 16px; margin: 0 0 12px 0; letter-spacing: 0.02em; }
            .muted { color: rgba(226, 232, 240, 0.78); font-size: 13px; line-height: 1.5; }
            .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
            .row { display: flex; gap: 10px; margin-top: 14px; align-items: center; }
            .dot {
              width: 10px; height: 10px; border-radius: 999px;
              background: #38bdf8;
              box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.55);
              animation: pulse 1.6s infinite;
            }
            @keyframes pulse {
              0% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.55); }
              70% { box-shadow: 0 0 0 12px rgba(56, 189, 248, 0.0); }
              100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.0); }
            }
          </style>
        </head>
        <body>
          <div class="card">
            <h1>Starting Codemm-Desktop…</h1>
            <div class="muted">
              Booting engine (agent + judge) and frontend UI locally.
              Docker is required for judging.
            </div>
            <div class="row muted">
              <div class="dot"></div>
              <div>Engine: <span class="mono">local IPC</span> · Frontend: <span class="mono">${frontendUrlHint}</span></div>
            </div>
            <div class="muted" style="margin-top: 14px;">
              If this hangs, check the terminal logs for missing deps.
            </div>
          </div>
        </body>
      </html>
    `)}`,
  );

  let backendProc = null;
  let frontendProc = null;

  const baseEnv = { ...process.env };
  // Improve odds of finding docker from a GUI-launched app (PATH can be minimal on macOS).
  baseEnv.DOCKER_PATH = dockerBin;
  if (dockerBin !== "docker") {
    const dockerDir = path.dirname(dockerBin);
    prependToPath(baseEnv, dockerDir);
  }

  // Load locally stored LLM settings (if configured). Secrets never go to renderer JS.
  const secrets = loadSecrets({ userDataDir: storage.userDataDir }).llm;

  // Ensure monorepo dependencies exist (npm workspaces).
  {
    if (!app.isPackaged) {
      const ok = await ensureNodeModules({ dir: repoRoot, label: "repo", env: baseEnv });
      if (!ok) {
        dialog.showErrorBox(
          "Dependencies Failed",
          `Failed to install npm dependencies in ${repoRoot}. Check terminal logs.`,
        );
        app.quit();
        return;
      }
    }
  }

  // Ensure Docker judge images exist (Codemm compiles/runs in Docker).
  {
    console.log("[ide] Ensuring judge Docker images...");
    const judgeContextDir = materializeJudgeBuildContext({ backendDir, userDataDir: storage.userDataDir });
    const ok = await ensureJudgeImages({ dockerBin, backendDir: judgeContextDir, env: baseEnv });
    if (!ok) {
      dialog.showErrorBox(
        "Judge Images Failed",
        "Failed to build judge Docker images. Check terminal logs and ensure Docker Desktop has enough resources.",
      );
      app.quit();
      return;
    }
  }

  // Start engine (workspace).
  console.log("[ide] Starting engine (IPC)...");
  if (!app.isPackaged) {
    console.log(`[ide] Engine nodeBin=${resolveNodeBin()}`);
  }
  const engineDbPath =
    typeof baseEnv.CODEMM_DB_PATH === "string" && baseEnv.CODEMM_DB_PATH.trim()
      ? baseEnv.CODEMM_DB_PATH.trim()
      : currentWorkspace.backendDbPath;

  backendProc = startEngineIpc({
    backendDir,
    env: {
      ...baseEnv,
      ...(app.isPackaged ? { NODE_ENV: "production", CODEMM_ENGINE_USE_DIST: "1" } : {}),
      CODEMM_DB_PATH: engineDbPath,
      CODEMM_WORKSPACE_DIR: currentWorkspace.workspaceDir,
    },
    onEvent: (evt) => {
      if (!evt || typeof evt.topic !== "string") return;
      if (evt.topic === "threads.generation") {
        try {
          mainWindow?.webContents?.send("codemm:threads:generationEvent", evt.payload);
        } catch {
          // ignore
        }
      }
    },
  });
  engine = backendProc;

  backendProc.proc.on("error", (err) => {
    dialog.showErrorBox("Engine Failed To Start", String(err?.message || err));
    app.quit();
  });

  backendProc.proc.on("exit", (code) => {
    if (!app.isQuiting) {
      dialog.showErrorBox(
        "Engine Exited",
        `Codemm engine exited unexpectedly (code=${code ?? "unknown"}). Check terminal logs.`,
      );
      app.quit();
    }
  });

  // Quick connectivity check (no ports/health endpoints).
  try {
    await backendProc.call("engine.ping", {});
    console.log("[ide] Engine is ready (IPC)");
  } catch (err) {
    dialog.showErrorBox("Engine Failed To Start", String(err?.message || err));
    backendProc.shutdown();
    app.quit();
    return;
  }

  // Configure LLM provider in-memory in the engine (avoid passing API keys via env).
  try {
    const provider = secrets && typeof secrets.provider === "string" ? secrets.provider.trim().toLowerCase() : null;
    const apiKey = secrets && typeof secrets.apiKey === "string" ? secrets.apiKey : null;
    const model = secrets && typeof secrets.model === "string" ? secrets.model : null;
    await backendProc.call("engine.configureLlm", { provider, apiKey, model, baseURL: null });
  } catch {
    // ignore; engine will error later if generation is attempted without configuration
  }

  const preferredFrontendPort = DEFAULT_FRONTEND_PORT;
  const frontendPort = await pickAvailablePort(preferredFrontendPort);
  const frontendUrl = `http://127.0.0.1:${frontendPort}`;
  const frontendToken = crypto.randomUUID();
  allowedFrontendOrigin = new URL(frontendUrl).origin;
  if (frontendPort !== preferredFrontendPort) {
    console.warn(`[ide] Frontend port ${preferredFrontendPort} is in use; using ${frontendPort} instead.`);
  }

  // Start frontend.
  const standaloneServer = path.join(frontendDir, ".next", "standalone", "server.js");
  const useStandalone = app.isPackaged || process.env.CODEMM_FRONTEND_MODE === "standalone";
  if (useStandalone) {
    if (!fs.existsSync(standaloneServer)) {
      dialog.showErrorBox(
        "Frontend Build Missing",
        [
          "Could not find the built Next standalone server.",
          "",
          `Expected: ${standaloneServer}`,
          "",
          "In dev, run: npm run build:frontend",
        ].join("\n"),
      );
      backendProc.shutdown();
      app.quit();
      return;
    }
    console.log(`[ide] Starting frontend (standalone) on ${frontendUrl}...`);
    const spawnFrontend = app.isPackaged ? spawnNodeWithElectron : spawnSystemNode;
    if (!app.isPackaged) {
      console.log(`[ide] Frontend nodeBin=${resolveNodeBin()}`);
    }
    frontendProc = spawnFrontend(standaloneServer, [], {
      cwd: path.dirname(standaloneServer),
      env: {
        ...baseEnv,
        PORT: String(frontendPort),
        HOSTNAME: "127.0.0.1",
        NODE_ENV: "production",
        NEXT_TELEMETRY_DISABLED: "1",
        CODEMM_FRONTEND_TOKEN: frontendToken,
      },
      stdio: ["ignore", "pipe", "pipe"],
    });
    frontendProc.unref();
  } else {
    console.log(`[ide] Starting frontend (dev) on ${frontendUrl}...`);
    const nextBin = path.join(repoRoot, "node_modules", "next", "dist", "bin", "next");
    if (!fs.existsSync(nextBin)) {
      dialog.showErrorBox(
        "Frontend Dependencies Missing",
        [
          "Could not find the Next.js CLI in node_modules.",
          "",
          `Expected: ${nextBin}`,
          "",
          "Run: npm install",
        ].join("\n"),
      );
      backendProc.shutdown();
      app.quit();
      return;
    }
    frontendProc = spawnSystemNode(
      nextBin,
      ["dev", "-p", String(frontendPort), "-H", "127.0.0.1"],
      {
        cwd: frontendDir,
        env: {
          ...baseEnv,
          PORT: String(frontendPort),
          HOSTNAME: "127.0.0.1",
          NEXT_TELEMETRY_DISABLED: "1",
          CODEMM_FRONTEND_TOKEN: frontendToken,
        },
        stdio: ["ignore", "pipe", "pipe"],
      },
    );
    frontendProc.unref();
  }
  wireLogs("frontend", frontendProc);
  frontendProc.on("error", (err) => {
    dialog.showErrorBox("Frontend Failed To Start", String(err?.message || err));
    app.quit();
  });

  frontendProc.on("exit", (code) => {
    if (!app.isQuiting) {
      dialog.showErrorBox(
        "Frontend Exited",
        `Codemm frontend exited unexpectedly (code=${code ?? "unknown"}). Check terminal logs.`,
      );
      app.quit();
    }
  });

  console.log(`[ide] Waiting for frontend health: ${frontendUrl}/codemm/health`);
  const frontendReady = await waitForFrontendReady(frontendUrl, { token: frontendToken, timeoutMs: 180_000 });
  if (!frontendReady) {
    dialog.showErrorBox(
      "Frontend Failed To Start",
      `Frontend did not become ready at ${frontendUrl} within timeout.`,
    );
    killProcessTree(frontendProc);
    try {
      backendProc?.shutdown?.();
    } catch {
      killProcessTree(backendProc?.proc);
    }
    app.quit();
    return;
  }

  console.log("[ide] Frontend is ready; loading UI...");
  await win.loadURL(frontendUrl);

  const cleanup = () => {
    killProcessTree(frontendProc);
    try {
      backendProc?.shutdown?.();
    } catch {
      killProcessTree(backendProc?.proc);
    }
  };

  app.on("before-quit", () => {
    app.isQuiting = true;
    cleanup();
  });
}

process.on("uncaughtException", (err) => {
  // Best-effort: surface fatal errors if Electron started from a GUI context.
  try {
    dialog.showErrorBox("Codemm-Desktop Crashed", redactSecrets(String(err?.stack || err?.message || err)));
  } catch {
    // ignore
  }
  // eslint-disable-next-line no-console
  console.error(redactSecrets(String(err?.stack || err?.message || err)));
});

process.on("unhandledRejection", (err) => {
  try {
    dialog.showErrorBox("Codemm-Desktop Error", redactSecrets(String(err?.stack || err?.message || err)));
  } catch {
    // ignore
  }
  // eslint-disable-next-line no-console
  console.error(redactSecrets(String(err?.stack || err?.message || err)));
});

app.whenReady().then(() => {
  console.log("[ide] Electron ready. Booting engine + frontend...");
  return createWindowAndBoot();
});

app.on("window-all-closed", () => {
  // On macOS, typical apps stay open without windows; for an IDE we quit.
  app.quit();
});

app.on("activate", () => {
  // macOS: clicking the dock icon should bring a window back.
  if (mainWindow) {
    mainWindow.show();
    return;
  }
  createWindowAndBoot().catch((err) => {
    try {
      dialog.showErrorBox("Failed To Launch", String(err?.stack || err?.message || err));
    } catch {
      // ignore
    }
  });
});
